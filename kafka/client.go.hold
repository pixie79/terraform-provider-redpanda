// Package kafka
package kafka

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"io"
	"net/http"
	"strings"
)

type ClientKafka struct {
	BOOTSTRAPSERVERS string
}

func NewClientKafka(bootstrapServers string) *ClientKafka {
	return &ClientKafka{
		BOOTSTRAPSERVERS: bootstrapServers,
	}
}

type TopicInfo struct {
	Topic string `json:"kafka"`
}

type TopicModel struct {
	Topic             types.String `tfsdk:"kafka"`
	ReplicationFactor types.Int64  `tfsdk:"replication_factor"`
	Partitions        types.Int64  `tfsdk:"partitions"`
	CleanupPolicy     types.String `tfsdk:"cleanup_policy"`
}

func (c *ClientKafka) CreateTopic(schema *TopicModel) error {

	topicInfo := TopicInfo{
		Topic: schema.Topic.ValueString(),
	}

	reqBody, err := json.Marshal(topicInfo)
	if err != nil {
		return err
	}

	topic := strings.Trim(schema.Topic.ValueString(), "\"")

	req, err := http.NewRequest("POST", fmt.Sprintf("%s/subjects/%s/versions", c.BOOTSTRAPSERVERS, topic), bytes.NewBuffer(reqBody))
	if err != nil {
		return err
	}
	req.Header.Set("Content-Type", "application/vnd.schemaregistry.v1+json")

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return err
	}
	defer func(Body io.ReadCloser) {
		err := Body.Close()
		if err != nil {
		}
	}(resp.Body)

	if resp.StatusCode != http.StatusOK {
		bodyBytes, _ := io.ReadAll(resp.Body)
		return errors.New(string(bodyBytes))
	}

	var topicResponse struct {
		Id int64 `json:"id"`
	}

	err = json.NewDecoder(resp.Body).Decode(&topicResponse)
	if err != nil {
		return err
	}

	//schema.ReplicationFactor = types.Int64Value(topicResponse.Id)
	//version, err := c.GetLatestVersion(subject)
	//if err != nil {
	//	return err
	//}
	//
	//schema.ReplicationFactor = types.Int64Value(version)
	return nil
}

//func (c *ClientKafka) GetLatestVersion(kafka string) (int64, error) {
//
//	req, err := http.NewRequest("GET", fmt.Sprintf("%s/subjects/%s/versions", c.APIURL, kafka), nil)
//	if err != nil {
//		return 0, err
//	}
//	req.Header.Set("Content-Type", "application/vnd.schemaregistry.v1+json")
//
//	resp, err := http.DefaultClient.Do(req)
//	if err != nil {
//		return 0, err
//	}
//	defer func(Body io.ReadCloser) {
//		err := Body.Close()
//		if err != nil {
//		}
//	}(resp.Body)
//
//	if resp.StatusCode != http.StatusOK {
//		bodyBytes, _ := io.ReadAll(resp.Body)
//		return 0, errors.New(string(bodyBytes))
//	}
//
//	var topicVersionResponse []int
//
//	err = json.NewDecoder(resp.Body).Decode(&topicVersionResponse)
//	if err != nil {
//		return 0, err
//	}
//
//	schemaVersionResponseLen := len(topicVersionResponse)
//	sort.Ints(topicVersionResponse)
//	version := topicVersionResponse[schemaVersionResponseLen-1]
//
//	return int64(version), nil
//
//}

//func (c *ClientKafka) GetTopic(kafka string, version int64) (*TopicModel, error) {
//	req, err := http.NewRequest("GET", fmt.Sprintf("%s/subjects/%s/versions/%d", c.APIURL, kafka, version), nil)
//	if err != nil {
//		return nil, err
//	}
//	req.Header.Set("Content-Type", "application/vnd.schemaregistry.v1+json")
//
//	resp, err := http.DefaultClient.Do(req)
//	if err != nil {
//		return nil, err
//	}
//	defer func(Body io.ReadCloser) {
//		err := Body.Close()
//		if err != nil {
//
//		}
//	}(resp.Body)
//
//	if resp.StatusCode != http.StatusOK {
//		bodyBytes, _ := io.ReadAll(resp.Body)
//		return nil, errors.New(string(bodyBytes))
//	}
//
//	var topicResponse struct {
//		Topic             string `json:"kafka"`
//		ReplicationFactor int64  `json:"replication_factor"`
//		Partitions        int64  `json:"partitions"`
//		CleanupPolicy     string `json:"cleanup_policy"`
//	}
//
//	err = json.NewDecoder(resp.Body).Decode(&topicResponse)
//	if err != nil {
//		return nil, err
//	}
//
//	//var schemaType string
//	//if topicResponse.SchemaType != "" {
//	//	schemaType = topicResponse.SchemaType
//	//} else {
//	//	schemaType = "AVRO"
//	//}
//
//	schema := &TopicModel{
//		Topic:             types.StringValue(topicResponse.Topic),
//		Partitions:        types.Int64Value(topicResponse.Partitions),
//		ReplicationFactor: types.Int64Value(topicResponse.ReplicationFactor),
//		CleanupPolicy:     types.StringValue(topicResponse.CleanupPolicy),
//	}
//
//	return schema, nil
//}

//func (c *ClientKafka) UpdateTopic(schema *TopicModel) error {
//	// Alias to CreateSchema as schemas are created as new versions
//	return c.CreateTopic(schema)
//}

//func (c *ClientKafka) DeleteTopic(kafka string) error {
//	req, err := http.NewRequest("DELETE", fmt.Sprintf("%s/subjects/%s", c.kafka, kafka), nil)
//	if err != nil {
//		return err
//	}
//	req.Header.Set("Content-Type", "application/vnd.schemaregistry.v1+json")
//
//	resp, err := http.DefaultClient.Do(req)
//	if err != nil {
//		return err
//	}
//	defer func(Body io.ReadCloser) {
//		err := Body.Close()
//		if err != nil {
//
//		}
//	}(resp.Body)
//
//	if resp.StatusCode != http.StatusOK {
//		bodyBytes, _ := io.ReadAll(resp.Body)
//		return errors.New(string(bodyBytes))
//	}
//
//	return nil
//}
